awesome—let’s add:

* 13. drag-and-drop task ordering
* 14. confetti + success chime on completion
* 15. PWA install + offline cache

Below are copy-paste snippets with exact file + placement. If any of your IDs differ, tell me and I’ll tweak.

---

# 1) Drag-and-drop task ordering

## A) index.html — make sure your task list has a stable ID and each task gets a `data-id`

If you already have a list, just ensure it’s inside an element with `id="quest-list"`. Example:

```html
<!-- Your Quests section -->
<div class="container" id="quests">
  <h2>Your Quests</h2>
  <ul id="quest-list"></ul>
</div>
```

When you render a task, the `<li>` should look like:

```html
<li class="quest-item" data-id="TASK_ID_HERE">
  <!-- your task content -->
</li>
```

## B) styles.css — add small visual cues

Paste near the bottom:

```css
/* Drag & drop visual cues */
#quest-list { list-style: none; padding: 0; margin: 0; }
.quest-item { cursor: move; user-select: none; }
.quest-item.dragging { opacity: 0.5; }
.quest-item.drop-marker { border-top: 3px dashed rgba(0,0,0,0.2); }
```

## C) main.js — add the DnD helpers and init

Paste **after** your existing functions (e.g., right after `processTaskInput()`), as standalone helpers:

```js
// ---- Drag & Drop Reorder ----
function loadTasks() {
  try { return JSON.parse(localStorage.getItem('tasks')) || []; }
  catch { return []; }
}

function saveTasks(tasks) {
  localStorage.setItem('tasks', JSON.stringify(tasks));
}

function persistTaskOrderFromDOM(listEl) {
  const ids = Array.from(listEl.children).map(li => li.dataset.id);
  const tasks = loadTasks();
  // If your task objects use a different id key, change 'id' below.
  tasks.sort((a, b) => ids.indexOf(String(a.id)) - ids.indexOf(String(b.id)));
  saveTasks(tasks);
}

function enableDragReorder(listEl) {
  if (!listEl) return;

  let draggingEl = null;
  let dropMarker = document.createElement('li');
  dropMarker.className = 'quest-item drop-marker';
  dropMarker.style.height = '0';

  listEl.addEventListener('dragstart', (e) => {
    const li = e.target.closest('.quest-item');
    if (!li) return;
    draggingEl = li;
    li.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    // Needed for Firefox
    e.dataTransfer.setData('text/plain', li.dataset.id || '');
  });

  listEl.addEventListener('dragend', () => {
    if (draggingEl) draggingEl.classList.remove('dragging');
    draggingEl = null;
    dropMarker.remove();
    persistTaskOrderFromDOM(listEl);
  });

  listEl.addEventListener('dragover', (e) => {
    e.preventDefault();
    const after = getDragAfterElement(listEl, e.clientY);
    if (!after) {
      listEl.appendChild(dropMarker);
    } else {
      listEl.insertBefore(dropMarker, after);
    }
  });

  listEl.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggingEl) return;
    const after = getDragAfterElement(listEl, e.clientY);
    if (!after) {
      listEl.appendChild(draggingEl);
    } else {
      listEl.insertBefore(draggingEl, after);
    }
    persistTaskOrderFromDOM(listEl);
  });

  // Make all items draggable
  Array.from(listEl.children).forEach(li => {
    if (li.classList.contains('quest-item')) {
      li.setAttribute('draggable', 'true');
    }
  });
}

function getDragAfterElement(container, y) {
  const items = [...container.querySelectorAll('.quest-item:not(.dragging):not(.drop-marker)')];
  let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
  for (const child of items) {
    const box = child.getBoundingClientRect();
    const offset = y - (box.top + box.height / 2);
    if (offset < 0 && offset > closest.offset) {
      closest = { offset, element: child };
    }
  }
  return closest.element;
}
```

Now, call `enableDragReorder(...)` **after you render tasks**. If you have a function like `renderTasks()` that fills `#quest-list`, add this line at the **end** of that function:

```js
enableDragReorder(document.getElementById('quest-list'));
```

And when you create each `<li>` for a task, be sure to include:

```js
li.classList.add('quest-item');
li.dataset.id = String(task.id); // ensure this matches your task object
li.setAttribute('draggable', 'true');
```

---

# 2) Confetti + success chime on completion

## A) index.html — add a canvas overlay (once)

Place just **before** the closing `</body>`:

```html
<canvas id="confetti-canvas"></canvas>
```

## B) styles.css — canvas overlay

Paste near bottom:

```css
#confetti-canvas {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
}
```

## C) main.js — confetti + chime helpers, then hook into completion

Paste near the bottom of `main.js` (but above any `export`/final lines):

```js
// ---- Confetti ----
let _confettiCanvas, _confettiCtx, _confettiRAF;

function fireConfetti(bursts = 180) {
  if (!_confettiCanvas) {
    _confettiCanvas = document.getElementById('confetti-canvas');
    if (!_confettiCanvas) return;
    _confettiCtx = _confettiCanvas.getContext('2d');
    const resize = () => {
      _confettiCanvas.width = window.innerWidth;
      _confettiCanvas.height = window.innerHeight;
    };
    window.addEventListener('resize', resize);
    resize();
  }

  const particles = [];
  const colors = ['#ffd166', '#06d6a0', '#118ab2', '#ef476f', '#8338ec'];
  const cx = _confettiCanvas.width / 2;
  const cy = _confettiCanvas.height / 3;

  for (let i = 0; i < bursts; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 4 + Math.random() * 6;
    particles.push({
      x: cx, y: cy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 6, // little upward pop
      g: 0.25 + Math.random() * 0.2,
      size: 2 + Math.random() * 3,
      life: 60 + Math.random() * 40,
      color: colors[(Math.random() * colors.length) | 0],
      spin: (Math.random() - 0.5) * 0.2,
      angle: Math.random() * Math.PI
    });
  }

  cancelAnimationFrame(_confettiRAF);
  const draw = () => {
    _confettiCtx.clearRect(0, 0, _confettiCanvas.width, _confettiCanvas.height);
    particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += p.g;
      p.angle += p.spin;
      p.life--;
      _confettiCtx.save();
      _confettiCtx.translate(p.x, p.y);
      _confettiCtx.rotate(p.angle);
      _confettiCtx.fillStyle = p.color;
      _confettiCtx.fillRect(-p.size, -p.size, p.size * 2, p.size * 2);
      _confettiCtx.restore();
    });
    for (let i = particles.length - 1; i >= 0; i--) {
      if (particles[i].life <= 0 || particles[i].y > _confettiCanvas.height + 20) {
        particles.splice(i, 1);
      }
    }
    if (particles.length) {
      _confettiRAF = requestAnimationFrame(draw);
    } else {
      _confettiCtx.clearRect(0, 0, _confettiCanvas.width, _confettiCanvas.height);
    }
  };
  draw();
}

// ---- Success Chime (Web Audio) ----
function playSuccessChime() {
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const ctx = new AudioCtx();
  const now = ctx.currentTime;

  function beep(freq, start, dur=0.12, type='sine') {
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, now + start);
    o.connect(g);
    g.connect(ctx.destination);
    g.gain.setValueAtTime(0.0001, now + start);
    g.gain.exponentialRampToValueAtTime(0.25, now + start + 0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, now + start + dur);
    o.start(now + start);
    o.stop(now + start + dur + 0.05);
  }

  // Simple ascending triad
  beep(523.25, 0.00, 0.12, 'triangle'); // C5
  beep(659.25, 0.12, 0.12, 'triangle'); // E5
  beep(783.99, 0.24, 0.16, 'triangle'); // G5
}
```

### Hook it into your completion flow

Open `main.js`, find the function that marks a task complete (commonly `completeTask(id)` or similar). **Right after** you save the new task state / update XP / re-render, add:

```js
// 🎉 Reward feedback
fireConfetti();
playSuccessChime();
```

(Place it only when the task is successfully completed—not when undoing.)

---

# 3) PWA install + offline cache

## A) Create `public/manifest.json` (or `/manifest.json` at project root)

```json
{
  "name": "TaskVenture",
  "short_name": "TaskVenture",
  "description": "Gamified quests, cards, and streaks.",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0b0e14",
  "theme_color": "#0b0e14",
  "icons": [
    { "src": "/icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png" }
  ]
}
```

> Export two square PNGs (192 & 512) from your logo and place them at `/icons/icon-192.png` and `/icons/icon-512.png`.

## B) Create `public/service-worker.js` (or `/service-worker.js` at root)

```js
/* TaskVenture service worker */
const CACHE = 'taskventure-v1';
const ASSETS = [
  '/',            // adjust if your index is not at root
  '/index.html',
  '/styles.css',
  '/main.js',
  '/manifest.json',
  '/icons/icon-192.png',
  '/icons/icon-512.png'
];

self.addEventListener('install', (e) => {
  e.waitUntil((async () => {
    const cache = await caches.open(CACHE);
    await cache.addAll(ASSETS);
    self.skipWaiting();
  })());
});

self.addEventListener('activate', (e) => {
  e.waitUntil((async () => {
    const keys = await caches.keys();
    await Promise.all(keys.map(k => (k !== CACHE ? caches.delete(k) : null)));
    self.clients.claim();
  })());
});

self.addEventListener('fetch', (e) => {
  const { request } = e;

  // Cache-first for same-origin GETs
  if (request.method === 'GET' && new URL(request.url).origin === location.origin) {
    e.respondWith((async () => {
      const cached = await caches.match(request);
      if (cached) return cached;
      try {
        const fresh = await fetch(request);
        // Optionally put fresh static assets in cache
        if (ASSETS.some(p => request.url.endsWith(p))) {
          const cache = await caches.open(CACHE);
          cache.put(request, fresh.clone());
        }
        return fresh;
      } catch {
        // Offline fallback for navigations
        if (request.mode === 'navigate') {
          return caches.match('/index.html');
        }
        throw err;
      }
    })());
  }
});
```

> If you later change file names, bump `CACHE` (e.g., `taskventure-v2`) so users get the new assets.

## C) index.html — add manifest link + theme color

Inside `<head>`:

```html
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#0b0e14">
```

Also add an install button (you can style later). Put this somewhere in your header or footer:

```html
<button id="install-btn" hidden>Install App</button>
```

## D) main.js — register SW + install prompt

Paste near the **top or bottom** of `main.js` (outside any function):

```js
// ---- PWA: register service worker ----
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js').catch(console.error);
}

// ---- PWA: Add to Home Screen prompt ----
let _deferredPrompt = null;
const installBtn = document.getElementById('install-btn');

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  _deferredPrompt = e;
  if (installBtn) installBtn.hidden = false;
});

if (installBtn) {
  installBtn.addEventListener('click', async () => {
    if (!_deferredPrompt) return;
    installBtn.disabled = true;
    _deferredPrompt.prompt();
    const { outcome } = await _deferredPrompt.userChoice;
    _deferredPrompt = null;
    installBtn.hidden = true;
    installBtn.disabled = false;
    // optional: toast outcome === 'accepted' ? 'Installed!' : 'Maybe later'
  });
}
```

---

## Final wiring checklist

* [ ] Your task `<li>`s have `.quest-item`, `data-id`, and `draggable="true"`.
* [ ] After rendering the list, call `enableDragReorder(document.getElementById('quest-list'));`
* [ ] In your complete-task function, call `fireConfetti()` and `playSuccessChime()` after success.
* [ ] Add `<canvas id="confetti-canvas"></canvas>` before `</body>`.
* [ ] Add `manifest.json`, `service-worker.js`, icons, and register the SW.
* [ ] Add `<link rel="manifest">` + `<meta name="theme-color">` + the “Install App” button.

Want me to tailor the selectors to your exact HTML (e.g., if your list is `#tasks-list` and items are `.task`)? Paste your current task list markup (just that section), and I’ll adjust the code precisely.
